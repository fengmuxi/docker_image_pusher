name: Docker-Build

on:
  issues:
    types:
      - opened

# https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token
permissions:
  issues: write


env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  PROJECT_SECRET_KEY: "${{ secrets.PROJECT_SECRET_KEY }}"

jobs:

  build:
    name: Pull
    runs-on: ubuntu-latest
    if: contains(github.event.issue.labels.*.name, 'build image')
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    - name: Check Issue
      id: get-image
      env:
        IMAGE: "${{ github.event.issue.title }}"
      run: |
        ORIGIN_IMAGE="${IMAGE}"
        ISSUE_BODY="${{ github.event.issue.body }}"
        # 提取构建镜像密码
        BUILD_PASSWORD=$(echo "$ISSUE_BODY" | awk -F '\n' '/构建镜像密码/ {getline; getline; print $0}' | sed 's/^[[:space:]]*//')
        # echo "构建镜像密码: $BUILD_PASSWORD"
        # 提取构建镜像 DockerFile 内容
        BUILD_DOCKERFILE=$(echo "$ISSUE_BODY" | awk '/构建镜像DockerFile/ {flag=1; next} flag {print}' | sed 's/^[[:space:]]*//')
        echo "构建镜像 DockerFile 内容:"
        echo "$BUILD_DOCKERFILE"
        
        # sudo chmod +x ./hack/verify.sh
        # PASSWORD="$(./hack/verify.sh "${BUILD_PASSWORD}")"
        if [[ "${PROJECT_SECRET_KEY}" != "${BUILD_PASSWORD}" ]]; then
          gh issue comment ${{ github.event.issue.number }} -b "构建镜像 '${ORIGIN_IMAGE}' 密码错误，请联系管理员"
          exit 1
        else
          NEW_ISSUE_BODY=$(echo "${{ github.event.issue.body }}" | awk -v password="${BUILD_PASSWORD}" '{gsub(password, "******"); print}')
          echo "新的issue内容: $NEW_ISSUE_BODY"
          gh issue edit ${{ github.event.issue.number }} --body "${NEW_ISSUE_BODY}"
        fi
        
        sudo chmod +x ./hack/supply-image.sh
        CORRECT_IMAGE="$(./hack/supply-image.sh "${ORIGIN_IMAGE}")"
        if [[ "${CORRECT_IMAGE}" == "" ]]; then
          gh issue comment ${{ github.event.issue.number }} -b "镜像 '${ORIGIN_IMAGE}' 名称不符合规范"
          exit 1
        fi
        
        echo "$BUILD_DOCKERFILE" > /tmp/Dockerfile
        echo "构建镜像 DockerFile 文件内容:"
        cat /tmp/Dockerfile
        echo "image=${ORIGIN_IMAGE}" >> $GITHUB_OUTPUT

    - name: Check Image
      run: |
        ORIGIN_IMAGE="${{ steps.get-image.outputs.image }}"
        gh issue comment ${{ github.event.issue.number }} -b "镜像 ${ORIGIN_IMAGE} 构建中...<br>[详情请查看](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})"

    - name: Before freeing up disk space
      run: |
        echo "Before freeing up disk space"
        echo "=============================================================================="
        df -hT
        echo "=============================================================================="

    # 增加可用磁盘空间
    - name: Maximize build space
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 2048
        swap-size-mb: 128
        remove-dotnet: 'true'
        remove-haskell: 'true'
        # 如果空间还是不够用，可以把以下开启，清理出更多空间
        # remove-android: 'true'
        # remove-codeql: 'true'
        build-mount-path: '/var/lib/docker/'

    - name: Restart docker
      run: sudo service docker restart

    - name: Free up disk space complete
      run: |
        echo "Free up disk space complete"
        echo "=============================================================================="
        df -hT
        echo "=============================================================================="

    - name: Docker Setup Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build and push image Aliyun
      id: build-image
      run: |
        ORIGIN_IMAGE="${{ steps.get-image.outputs.image }}"
        docker login -u $ALIYUN_REGISTRY_USER -p $ALIYUN_REGISTRY_PASSWORD $ALIYUN_REGISTRY
        
        # 获取镜像名和版本字符串
        # 检查是否包含逗号分割的版本
        if echo "$ORIGIN_IMAGE" | grep -q ','; then
            # 格式: image_name:v1.0.0,v1.1.0,v2.0.0
            base_image=$(echo "$ORIGIN_IMAGE" | awk -F':' '{print $1}')
            versions=$(echo "$ORIGIN_IMAGE" | awk -F':' '{print $2}')
            echo "base_image: $base_image"
            echo "versions: $versions"
            
            # 分割版本字符串
            IFS=',' read -ra version_array <<< "$versions"
        else
            # 单版本格式: image_name:v1.0.0 或 image_name
            if echo "$ORIGIN_IMAGE" | grep -q ':'; then
                base_image=$(echo "$ORIGIN_IMAGE" | awk -F':' '{print $1}')
                version_array=($(echo "$ORIGIN_IMAGE" | awk -F':' '{print $2}'))
            else
                base_image="$ORIGIN_IMAGE"
                version_array=("latest")
            fi
        fi
        
        # 构建基础镜像
        echo "docker build -t ${base_image}:latest -f /tmp/Dockerfile ."
        docker build -t ${base_image}:latest -f /tmp/Dockerfile .
        
        # 为每个版本构建、标记并推送
        for version in "${version_array[@]}"; do
            echo "处理版本: $version"
            
            # 构建特定版本镜像
            image_name_tag="${base_image}:${version}"
            echo "docker tag ${base_image}:latest $image_name_tag"
            docker tag ${base_image}:latest $image_name_tag
            
            # 标记并推送到阿里云
            new_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/${image_name_tag}"
            echo "docker tag $image_name_tag $new_image"
            docker tag $image_name_tag $new_image
            echo "docker push $new_image"
            docker push $new_image
            
            # 记录第一个推送的镜像用于输出
            if [[ -z "$FIRST_IMAGE" ]]; then
                FIRST_IMAGE="$new_image"
            fi
        done
        
        echo "开始清理磁盘空间"
        echo "=============================================================================="
        df -hT
        echo "=============================================================================="
        
        # 清理本地镜像
        docker rmi ${base_image}:latest
        for version in "${version_array[@]}"; do
            docker rmi ${base_image}:${version}
            docker rmi "$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/${base_image}:${version}"
        done
        
        echo "磁盘空间清理完毕"
        echo "=============================================================================="
        df -hT
        echo "=============================================================================="
        echo "image=${FIRST_IMAGE}" >> $GITHUB_OUTPUT

    - name: Fail Build
      if: failure()
      run: |
        ORIGIN_IMAGE="${{ steps.get-image.outputs.image }}"
        gh issue comment ${{ github.event.issue.number }} -b "镜像 ${ORIGIN_IMAGE} 构建失败[详情请查看](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})<br>如有疑问请回复 /auto-cc 召唤帮助, 或者查看[构建成功案例](https://github.com/${{ github.repository }}/issues?q=is%3Aissue+is%3Aclosed+label%3A%22build+image+succeeded%22)"
        gh issue edit ${{ github.event.issue.number }} --add-label "build image failure" -b "IMAGE BUILD"
        gh issue close ${{ github.event.issue.number }} --reason "not planned"

    - name: Success Build
      if: success()
      run: |
        ORIGIN_IMAGE="${{ steps.get-image.outputs.image }}"
        NEW_IMAGE="${{ steps.build-image.outputs.image }}"
        gh issue comment ${{ github.event.issue.number }} -b "镜像 ${ORIGIN_IMAGE} 构建完成<br>请使用 $NEW_IMAGE 替代源镜像"
        gh issue edit ${{ github.event.issue.number }} --add-label "build image succeeded" -b "IMAGE BUILD"
        gh issue close ${{ github.event.issue.number }} --reason "completed"